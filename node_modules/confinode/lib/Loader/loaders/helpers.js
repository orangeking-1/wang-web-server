"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const utils_1 = require("../../utils");
/**
 * The babel files regular expression. Taken from the Gulp “interpret” project:
 * https://github.com/gulpjs/interpret.
 */
exports.noEndsInBabelJs = /(?!\.babel\.[jt]s(x))$/;
/**
 * Check if file is a babel or node module. Taken from the Gulp “interpret” project:
 * https://github.com/gulpjs/interpret.
 *
 * @param file - The file to test.
 * @returns False if file is babel or node module and should not be ignored.
 */
function ignoreNonBabelAndNodeModules(file) {
    return (exports.noEndsInBabelJs.test(file) &&
        path_1.relative(process.cwd(), file)
            .split(path_1.sep)
            .indexOf('node_modules') >= 0);
}
exports.ignoreNonBabelAndNodeModules = ignoreNonBabelAndNodeModules;
/**
 * Indicate if the description is a loader description.
 *
 * @param value - The description to check.
 * @returns True if loader description.
 */
function isLoaderDescription(value) {
    return 'filetypes' in value;
}
/**
 * Analyze the loaders to create both loader descriptions and extensions loaders.
 *
 * @param loaders - The loaders to analyze.
 * @param namePrefix - The prefix to add to loader names.
 * @returns The analyze result.
 */
function analyzeLoaders(loaders, namePrefix = '') {
    const loaderDescriptions = {};
    const extensionsLoaders = Object.entries(Object.entries(loaders)
        .map(([name, description]) => ({ ...description, name }))
        .filter(isLoaderDescription)
        .reduce((previous, loaderDescription) => {
        const { filetypes, name, ...description } = loaderDescription;
        loaderDescriptions[namePrefix + name] = Object.freeze(description);
        utils_1.ensureArray(filetypes).forEach(filetype => {
            if (!filetype) {
                throw new Error('Empty file type is forbidden');
            }
            if (!(filetype in previous)) {
                previous[filetype] = [];
            }
            previous[filetype].push(namePrefix + name);
        });
        return previous;
    }, {})).reduce((previous, [extension, descriptionNames]) => {
        previous[extension] = Object.freeze(descriptionNames);
        return previous;
    }, {});
    return [Object.freeze(loaderDescriptions), Object.freeze(extensionsLoaders)];
}
exports.analyzeLoaders = analyzeLoaders;
//# sourceMappingURL=helpers.js.map