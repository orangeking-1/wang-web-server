"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const utils_1 = require("../utils");
/**
 * Create a request for if given parameter is a folder.
 *
 * @param path - The path to test.
 * @returns The request.
 */
function requestIsFolder(path) {
    return { request: 0 /* IsFolder */, payload: path };
}
exports.requestIsFolder = requestIsFolder;
/**
 * Create a request for if the given parameter is an existing file.
 *
 * @param file - The file to test.
 * @returns The request.
 */
function requestFileExits(file) {
    return { request: 1 /* FileExists */, payload: file };
}
exports.requestFileExits = requestFileExits;
/**
 * Create a request for the content of the folder given as parameter.
 *
 * @param folder - The folder to read.
 * @returns The request.
 */
function requestFolderContent(folder) {
    return { request: 2 /* FolderContent */, payload: folder };
}
exports.requestFolderContent = requestFolderContent;
/**
 * Create a request for the configuration file content loading.
 *
 * @param filePath - The path of the file to load.
 * @param loader - The loader to use.
 * @returns The request.
 */
function requestLoadConfigFile(filePath, loader) {
    return { request: 3 /* LoadConfigFile */, payload: { filePath, loader } };
}
exports.requestLoadConfigFile = requestLoadConfigFile;
/**
 * Execute a function, given as a generator, used asynchronously.
 *
 * @param stepRun - The function to execute. The function is a generator which may stop to request some
 * information.
 * @returns The return value of the given function.
 */
async function asyncExecute(stepRun) {
    let current = stepRun.next();
    while (!current.done) {
        try {
            const request = current.value;
            let response;
            switch (request.request) {
                case 0 /* IsFolder */:
                    response = await new Promise(res => fs_1.stat(request.payload, (err, stats) => {
                        err ? /* istanbul ignore next */ res(false) : res(stats.isDirectory());
                    }));
                    break;
                case 1 /* FileExists */:
                    response = await new Promise(res => fs_1.access(request.payload, fs_1.constants.F_OK, err => res(!err)));
                    break;
                case 2 /* FolderContent */:
                    response = await new Promise(res => fs_1.readdir(request.payload, (err, files) => res(!err ? files : [])));
                    break;
                case 3 /* LoadConfigFile */:
                    response = await request.payload.loader.load(request.payload.filePath);
                    break;
                /* istanbul ignore next */
                default:
                    utils_1.assertNever(request, 'channel request');
            }
            current = stepRun.next(response);
        }
        catch (e) {
            current = stepRun.throw(e);
        }
    }
    return current.value;
}
exports.asyncExecute = asyncExecute;
/**
 * Execute a function, given as a generator, used synchronously.
 *
 * @param stepRun - The function to execute. The function is a generator which may stop to request some
 * information.
 * @returns The return value of the given function.
 */
function syncExecute(stepRun) {
    let current = stepRun.next();
    while (!current.done) {
        try {
            const request = current.value;
            let response;
            switch (request.request) {
                case 0 /* IsFolder */:
                    response = (() => {
                        try {
                            return fs_1.statSync(request.payload).isDirectory();
                        }
                        catch (_a) {
                            /* istanbul ignore next */
                            return false;
                        }
                    })();
                    break;
                case 1 /* FileExists */:
                    response = (() => {
                        try {
                            fs_1.accessSync(request.payload, fs_1.constants.F_OK);
                            return true;
                        }
                        catch (_a) {
                            return false;
                        }
                    })();
                    break;
                case 2 /* FolderContent */:
                    response = (() => {
                        try {
                            return fs_1.readdirSync(request.payload);
                        }
                        catch (_a) {
                            return [];
                        }
                    })();
                    break;
                case 3 /* LoadConfigFile */:
                    response = request.payload.loader.syncLoad(request.payload.filePath);
                    break;
                /* istanbul ignore next */
                default:
                    utils_1.assertNever(request, 'channel request');
            }
            current = stepRun.next(response);
        }
        catch (e) {
            current = stepRun.throw(e);
        }
    }
    return current.value;
}
exports.syncExecute = syncExecute;
//# sourceMappingURL=synchronization.js.map